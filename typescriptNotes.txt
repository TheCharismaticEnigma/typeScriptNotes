TYPESCRIPT: 

NOTE: TS is like having JS with JAVA features and behavior .  

- A programming language to address shortcomings of JS 
- Built on top of JS. Every JS file is a TS file. 
- can be used on frontend and backend. Anything js does, TS does too.
- Superset of JS. In TS File all js code is valid TS code.  

DRAWBACKS: 

- compilation (parsing and convertion from TS to JS) is always needed 
because browsers right now can't understand TS. 

- TS compiler takes TS code and converts to js code. (TRANSPILATION) 

- More discipline required. So, use for med-large size projects. 

- npm needed to install typescript compiler 

Benefits of TS : 
--------------

Type Checking  
AUTO Code Completion  
Refactoring 
New Features 

a) static typing: 
- can have data types for variables 
- explicitly set the data type of variables at compile time (like JAVA)
- code is parsed by TS compiler and errors are displayed at compile time

- We don't have to run our application to get the syntax 
errors at runtime.


Installation using node/npm :
------------------------------ 

npm i -g typescript 

tsc -v  ... (typescript compiler --version)

In terminal/git bash: 

tsc file.ts  ==> compiles and produces another file.js file which contains
compiled code in js.  

FOR COMPILING TS code write this in terminal... tsc file.ts 

ANNOTATING A VARIABLE TO a given type : 
-------------------------------------

let age: number = 20 ; 

CONFIGURING file for the typescript compiler (tsc) : 
In the terminal , 
tsc --init

By convention: 
PUT the source TS files/code inside a folder.(src) 
And the compiled files will be in dist(ributable) folder. 

Modify: 

rootDir: "./src" -> where our ts files will be stored 
outDir: "./dist" -> where our js files will be stored (distributable folder)
removeComments : true => our compiled JS won't contain any commends in TS files. 
noEmitOnError: true => tsc won't generate js files if error in ts files. 
sourceMap: true => specifies how each line of ts maps to generated line of JS code. 
                   creates a .js.map file in dist folder for debuggers . 

After configuring, we can compile all files in project by simply 
running tsc in terminal without file name. 
So all ts files => src directory
   all js files => dist(ributable) directory 

Configure the tsc by en/disabling various settings in tsconfig.json
file generated using tsc -init command. 

BUILT IN TYPES: 

JS - number, string, boolean, undefined,
              null, bigInt, symbol, object

TS - any, enum, tuple,unknown, never

In TS, separate a large number's digits with _ 
let sales:number = 123_456_789 ; 

NOTE: TS compiler automatically infers/detects the data type of 
a variable without you annotating it to the 
variable (based on the value) ; 
Ex. let theName:number = 123 ; .... (same as let theName = 123) 

If variable is declared and not initialized with a value --> 
TS implicitly gives it type ANY as We can set it to any value (like in JS)
Which doesn't make sense because it is JS behavior 

function render(document:any) { ... }

IMPORTANT: not recommended. 
To remove these erros, in tsconfig.json file set the noImplicitAny:false

ARRAYS: 

In JS arrays, each element can have DIFFERENT DATA TYPE.
IN TS, explicit data type annotation(adding notes for explanation)
of the data type to an array is possible 

let numbers:number[] = [1,2,3,4] ; 

If empty array, by default type is any[] (that is JS arrays) 

TUPLES: 
- fixed length array with each element having a particular type.
- used when working with pair of values. 
- internally represented using JS[]. After compilation, converted 
  to regular js[] . 
- Best Practice: Restrict tuple to size of 2 (like key value pair)

let user : [number, string] = [102121, 'Mosh Hamedani'] ; 

ENUMS: 
-----

- represents list of RELATED CONSTANTS (grouped together) 
- follows PASCALNAMINGCONVENTION for enum name and members 
- by default values are given from 0, 1, ... for each member. 
- Can explictly assign desired values (also strings) for constants. 

NOTE: If enums are defined using CONSTANTs, TS comiler generates More
optimized JS code while TRANSPILATION. 

const enum Name {
  first = "Avi",
  mid = "V",
  last = "Wal",
}
const first: Name = Name.first;
const mid: Name = Name.mid;
const last: Name = Name.last;

const fullName = `My full name is ${first} ${mid} ${last}`;

FUNCTIONS: 
---------

- AS best practice, ALL PARAMETERS AND RETURN TYPES of FUNCTIONS
should be annotated. TS enables that. 
- enables to set the return type of function 
- return type is void IF NO value is returned from function 
- compilation error if local variables are defined and not used 
- compilation error for unused parameters 
- JS by default always returns undefined from our functions. So TS compiler
warns us as returning undefined from function can cause bugs.

- Unlike in JS where arguments can be more/less than parameter count, 
argument count and type in TS must be exactly matching
to that of parameters count and data type annotated to parameters. (like JAVA)

- Can make a parameter optional using syntax: 
parameterName?:number  

function tax (income:number):void { 
    ... calculates tax but returns no value as return 
    type is set to void. 

    return ; 
}

function getSize (size?:number):number { 
    Here size is an OPTIONAL parameter. 
    by default parameters are undefined 
    if arguments are not passed but still used. 

    return size || 12  ;  
}


NOTE: 
1. Use tsc (typescript compiler) to transpile the code 
2. Then use node ... path to js file command to run JS in terminal
Ex. tsc index.ts 
    node ./dist/index.js


OBJECTS: 

- In JS, objects are dynamic. 
- object structure can be annotated like variable data type. 
- properties can be made optional 
- readonly keyword can be used to make a property read only
- for methods, their signature must be annotated 

let Person: {
  name: string;
  readonly birthYear: number;
  age?: () => number;
} = {
  name: "Enigma",
  birthYear: 1993,
  age: function () {
    return 2023 - this.birthYear;
  },
};

TOPIC: TYPE ALIASES: (Custom Types)  
-------------------

NOTE: Using TYPE ALIASES we can define a custom type. 
CAN solve all problems in above object structure: 

1. Too hard to understand

2. Doesn't have a dynamic structure. Has a fixed SHAPE.  
     New objects can have different properties. 

3. To create another similar object, we'd have to repeat structure. 
   And thus violate DRY structure 

Using type ALIASES, can set the structure at one place and 
reuse it multiple times. (like classes and Objects) 

type Employee = { 
  readonly id: number, 
  name: string, 
  retire: (date: Date) => void 
}

let employee1 : Employee = { 
  id: 1, 
  name: 'AH', 
  reture: (date: Date) => console.log(date) ; 
}

let employee2 : Employee = { 
  id: 2, 
  name: 'TS', 
  reture: (date: Date) => console.log(date) ; 
}

NOTE: Using type ALIASES, we can define a object structure once
and reuse it with different values multiple times. 


TOPIC: UNION TYPES 
------------------

- With Union Types (|) can give a function/variable parameter of
  more than one data type. It can be one of many types 

- The parameter can be of one/more Data types. And so we handle 
multiple different scenarios. 

function kgToLbs (weight: number|string): number { 
  weight can be of type number or of type string. 

  // Then for each data type we handle the case 

  if (typeof weight === 'number')
    .... 
  
  if (typeof weight == 'string') .... 
}


TOPIC: INTERSECTION TYPES : 
----------------------------

- used for parameters/variables which are an intersection of MULTIPLE 
DATA TYPES. 

- used for CUSTOM type ALIASES. 
ex. Parameter should be of type Draggable and Resizable

- Can create a new Type which is intersection/combination of MULTIPLE
types.   ex. type UIWidget = Draggable & Resizable ; 

type Draggable = { 
  drag: () => void ; 
}

type Resizable = { 
  resize: () => void 
}

// In the new type, initialize ALL MEMBERS OF Draggable and Resizable
// object. 

type UIWidget = Draggable & Resizable ;

let textBox: UIWidget = { 
  drag: () => {}, 
  resize: () => { }, 
}

TOPIC: LITERAL TYPES : 
--------------------

- limiting values assigned to a variable. 
- we annotate variable with LITERAL/Exact/specific value(s) 
- the variable MUST be set to one of those values. 
- Literals can be Strings, numbers, and etc. 

type Units = 'kg' | 'lbs' ; (Type ALIASES + Union Type) 

let unit1 : Units = 'kg' ; 
let unit2 : Units = 'lbs' ; 

// Anything else won't be accepted. 


TOPIC: Nullable Types (null | undefined) 

- by default TS doesn't allow nullable types to be passed 
- if in case we need them we can pass using UNION Types. 

Ex. name: string|null|undefined 


TOPIC: OPTIONAL CHAINING: 
------------------------

- enables error handling without if.. else statements. 
- Used in combination with Nullish Coaelscing Operator. 
- (?. + ??) to have a fallback default value. 

Ex. customer?.birthday?.getFullYear() ; 
Ex. customers?.[0] 
Ex. variableName?.(arguments..) . 

Above code expressions Will be executed if variable name
    references an actual function/object


WHEN working will nullish values, you need a fallback default 
value ==> Nullish Coaelscing Operator is used for that 
Ex. customers?.[0] ?? 'No Customers' 


TOPIC: Type Assertions: (as keyword OR <>) 
-----------------------

IMPORTANT: The 'as' keyword doesn't perform any TYPE CONVERSION. 
It just asserts that we know more about the data type of an element 
than TSC 

let phone = document.getElementById('phone') as HTMLInputElement ; 
phone.value 

NOTE: IF the object is not of Assterted type (HTMLInputElement), 
then at the point where we're trying to access value property, 
the code will crash. THERE IS NO TYPE CONVERSION. 

SYNTAX-1 : 
let phone = <HTMLInputElement> document.getElementById('phone') ; 

SYNTAX-2 : 
let phone = document.getElementById('phone') as HTMLInputElement ; 


TOPIC: UNKNOWN TYPE 
--------------------

- Safer version of any. Represents Any value but unlike any, we 
can't perform any operatons on unknown type BEFORE using type-GUARD
for different types. 

NOTE: USING UNKNOWN TYPE >>>> ANY TYPE. 
As compiler makes us to use TYPE-Checking to make sure that 
methods we're calling exist

In any type compiler does no checking 

Used Where we don't know the TYPE Of element beforehand, and 
there can be multiple data types possible. 

Can use NARROWING USING TYPE-GUARD to handle multiple scenarios. 

1. if (typeof document === 'string') { 
       .. here we'll have access to all string methods.
       as TSC knows that this document is a string object. 
   }

NOTE: typeof operator -> works for primitive types 
If custom object is created from classes then , 
instanceOf operator

Ex. function render (document:unknown) { 
    if primitive type => typeof 
    if reference type => instanceof 

    if (typeof document === 'number') { 
      .... access to all inbuilt number methods
    }

    if (typeof document === 'string') { 
      ... access to all inbuilt number methods. 
    }
}

TOPIC => NEVER TYPE
-------------------

- Represents value that never occur. 
- Helps detect UNREACHABLE CODE which would be ignored otherwise. 
- Compiler infers return type void and thus the UNREACHABLE code isn't 
detected.

NOTE: CASE 1 

function reject(message:string ='Error Message'): never { 
  ... 
  throw new Error(message) ; 
}

reject() ; 
console.log('This is an unreachable code which will be detected now
at compile time only') ; 

NOTE: CASE 2 

function reject(message:string ='Error Message') { 
  ... 
  throw new Error(message) ; 
}

reject() ; 

console.log('This is an unreachable code that will NOT
be detected now at compile time because Compiler infers the 
return type of reject function to be void. ') ; 


